<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.TokenLab.simulationcomponents.pricingclasses API documentation</title>
<meta name="description" content="Created on Wed Nov 23 11:54:33 2022 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.TokenLab.simulationcomponents.pricingclasses</code></h1>
</header>
<section id="section-intro">
<p>Created on Wed Nov 23 11:54:33 2022</p>
<p>@author: stylianoskampakis</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Wed Nov 23 11:54:33 2022

@author: stylianoskampakis
&#34;&#34;&#34;

import numpy as np
import scipy
from scipy.stats import binom,norm
from typing import Union,TypeVar,Callable
from typing import List, Dict,Union,Tuple
from baseclasses import Controller,TokenEconomy,AddOn
import pandas as pd
from tqdm import tqdm
from matplotlib import pyplot as plt
import time
from addons import AddOn_RandomNoise, AddOn_RandomNoiseProportional


class HoldingTimeController(Controller):
    &#34;&#34;&#34;
    Abstract class from which all HoldingTime controllers should inherit.
    &#34;&#34;&#34;
    
    def __init__(self):
        super(HoldingTimeController,self).__init__()
        self.holding_time=None

    
    def get_holding_time(self)-&gt;float:
        return self.holding_time
    
    def execute(self)-&gt;float:
        
        pass
    
    
class HoldingTime_Constant(HoldingTimeController):
    &#34;&#34;&#34;
    Constant holding time
    &#34;&#34;&#34;
    
    def __init__(self,holding_time:float):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        holding_time : float
            The holding time. Needs to be positive.

        Raises
        ------
        Exception
            If holding_time&lt;0 then raise Exception.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super(HoldingTime_Constant,self).__init__()

        if holding_time&lt;=0:
            raise Exception(&#39;Holding time needs to be a positive real value!&#39;)
        self.holding_time=holding_time

class HoldingTime_Stochastic(HoldingTimeController):
    &#34;&#34;&#34;
    Uses a probability distribution and samples a random holding time per iteration.
    &#34;&#34;&#34;
    
    def __init__(self,holding_time_dist:scipy.stats=scipy.stats.halfnorm,holding_time_params:Dict={&#39;loc&#39;:0,&#39;scale&#39;:1},
                 minimum:float=0.1):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        holding_time_dist : scipy.stats, optional
           A scipy distribution to sample the holding time from. The default is scipy.stats.halfnorm.
        holding_time_params : Dict, optional
            The parameters of the distribution. The default is {&#39;loc&#39;:0,&#39;scale&#39;:1}.
        minimum : float, optional
            The minimum possible holding time. If the sampled holding time is &lt;1, then it reverts to minimum. The default is 0.1.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.distribution=holding_time_dist
        self.dist_params=holding_time_params
        self.minimum=minimum
        self.execute()
        
        
    def execute(self)-&gt;float:
        &#34;&#34;&#34;
        

        Returns
        -------
        float
            The holding time.

        &#34;&#34;&#34;
        seed=int(int(time.time())*np.random.rand())

        self.holding_time=self.distribution.rvs(size=1,**self.dist_params,random_state=seed)[0]
        if self.holding_time&lt;self.minimum:
            self.holding_time=self.minimum
        
        return self.holding_time
    
class HoldingTime_Adaptive(HoldingTimeController):
    
    &#34;&#34;&#34;
    Recalculates holding time based on transaction volume and price.
    
    It includes minimum and maximum values. If these are not set, then the calculations can get out of hand
    into unrealistic values. The maximum value of 12 is set based on the assumption that the unit of time is a month.
    Hence, the maximum holding time (by default) is set to 1 year.
    
    &#34;&#34;&#34;
    def __init__(self,holding_time,noise_addon:AddOn=None,minimum:float=0.01,maximum:float=12):
        self.dependencies={TokenEconomy:None}
        super(HoldingTime_Adaptive,self).__init__()

        if holding_time&lt;=0:
            raise Exception(&#39;Holding time needs to be a positive real value!&#39;)
        self.holding_time=holding_time
        self._noise_addon=noise_addon
        self.minimum=minimum
        self.maximum=maximum
        
        
    def execute(self)-&gt;float:
        tokeneconomy=self.dependencies[TokenEconomy]
        
        holding_time=tokeneconomy.price*tokeneconomy.transactions_volume_in_tokens/(tokeneconomy.transactions_value_in_fiat++0.000000001)
        
        if self._noise_addon!=None:
            dummy=self._noise_addon.apply(**{&#39;value&#39;:price_new})

            if dummy+holding_time&gt;0:
                holding_time=dummy+holding_time
        if holding_time&lt;self.minimum:
            holding_time=self.minimum
        elif holding_time&gt;self.maximum:
            holding_time=self.maximum
        
        self.holding_time=holding_time
        
        
class PriceFunctionController(Controller):
    &#34;&#34;&#34;
    Abstract class for price controllers.
    
    &#34;&#34;&#34;
        
    
    def __init__(self):
       super(PriceFunctionController,self).__init__()
       self.dependencies={TokenEconomy:None}
       self.price=None
    
    def execute(self)-&gt;float:
        iteration+=1
        pass
    
    def get_price(self)-&gt;float:
        
        return self.price
    
    
    
    
class PriceFunction_EOE(PriceFunctionController):
    &#34;&#34;&#34;
    Simple implementation of equation of exchange. Can also implement noise through AddOns.
    
    If the AddOns make the price go negative, then the price goes back to simple equation of exchange before 
    noise w as added.
    &#34;&#34;&#34;
    
    def __init__(self,noise_addon:AddOn=None,smoothing_param:float=1):
        &#34;&#34;&#34;
        
        Parameters
        ----------
        
        noise_AddOn: Optional, if this is used, then the noise is added to the price.
        If the price is negative, then the noise add-on is ignored, and the returned price
        is the price without the noise.
        
        smoothing_param: Float. If set below 1, then this applied a weighted average between the new price
        and the old price. This causes an anchoring effect, since in practice the new price would 
        be anchored to some extent to the previous one. A smoothing_param of 0.9, for exaple
        calculates the final price as 0.9*newprice+0.1*old_price
        &#34;&#34;&#34;
        super(PriceFunction_EOE,self).__init__()
        self._noise_addon=noise_addon
        
        if smoothing_param&gt;1 or smoothing_param&lt;0:
            raise Exception(&#39;Smoothing param must be in [0,1]&#39;)
        else:
            self.smoothing_param=smoothing_param
    
    def execute(self)-&gt;float:  
        tokeneconomy=self.dependencies[TokenEconomy]
        
        transaction_volume_in_fiat=tokeneconomy.transactions_value_in_fiat
        holding_time=tokeneconomy.holding_time
        #supply_of_tokens=tokeneconomy.transactions_value_in_tokens
        supply_of_tokens=tokeneconomy.supply
        
                

        #noise adjustment
        price_new=holding_time*transaction_volume_in_fiat/supply_of_tokens
        
        price_new=self.smoothing_param*price_new+(1-self.smoothing_param)*tokeneconomy.price
        
        if self._noise_addon!=None:
            price_new_2=self._noise_addon.apply(**{&#39;value&#39;:price_new})
        else:
            price_new_2 = -1
            
        if price_new_2&lt;0:
            self.price=price_new
        else:
            self.price=price_new_2
        
        self.iteration+=1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController"><code class="flex name class">
<span>class <span class="ident">HoldingTimeController</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class from which all HoldingTime controllers should inherit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoldingTimeController(Controller):
    &#34;&#34;&#34;
    Abstract class from which all HoldingTime controllers should inherit.
    &#34;&#34;&#34;
    
    def __init__(self):
        super(HoldingTimeController,self).__init__()
        self.holding_time=None

    
    def get_holding_time(self)-&gt;float:
        return self.holding_time
    
    def execute(self)-&gt;float:
        
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>baseclasses.Controller</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive">HoldingTime_Adaptive</a></li>
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Constant" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Constant">HoldingTime_Constant</a></li>
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic">HoldingTime_Stochastic</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self)-&gt;float:
    
    pass</code></pre>
</details>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.get_holding_time"><code class="name flex">
<span>def <span class="ident">get_holding_time</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_holding_time(self)-&gt;float:
    return self.holding_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive"><code class="flex name class">
<span>class <span class="ident">HoldingTime_Adaptive</span></span>
<span>(</span><span>holding_time, noise_addon: baseclasses.AddOn = None, minimum: float = 0.01, maximum: float = 12)</span>
</code></dt>
<dd>
<div class="desc"><p>Recalculates holding time based on transaction volume and price.</p>
<p>It includes minimum and maximum values. If these are not set, then the calculations can get out of hand
into unrealistic values. The maximum value of 12 is set based on the assumption that the unit of time is a month.
Hence, the maximum holding time (by default) is set to 1 year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoldingTime_Adaptive(HoldingTimeController):
    
    &#34;&#34;&#34;
    Recalculates holding time based on transaction volume and price.
    
    It includes minimum and maximum values. If these are not set, then the calculations can get out of hand
    into unrealistic values. The maximum value of 12 is set based on the assumption that the unit of time is a month.
    Hence, the maximum holding time (by default) is set to 1 year.
    
    &#34;&#34;&#34;
    def __init__(self,holding_time,noise_addon:AddOn=None,minimum:float=0.01,maximum:float=12):
        self.dependencies={TokenEconomy:None}
        super(HoldingTime_Adaptive,self).__init__()

        if holding_time&lt;=0:
            raise Exception(&#39;Holding time needs to be a positive real value!&#39;)
        self.holding_time=holding_time
        self._noise_addon=noise_addon
        self.minimum=minimum
        self.maximum=maximum
        
        
    def execute(self)-&gt;float:
        tokeneconomy=self.dependencies[TokenEconomy]
        
        holding_time=tokeneconomy.price*tokeneconomy.transactions_volume_in_tokens/(tokeneconomy.transactions_value_in_fiat++0.000000001)
        
        if self._noise_addon!=None:
            dummy=self._noise_addon.apply(**{&#39;value&#39;:price_new})

            if dummy+holding_time&gt;0:
                holding_time=dummy+holding_time
        if holding_time&lt;self.minimum:
            holding_time=self.minimum
        elif holding_time&gt;self.maximum:
            holding_time=self.maximum
        
        self.holding_time=holding_time</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController">HoldingTimeController</a></li>
<li>baseclasses.Controller</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self)-&gt;float:
    tokeneconomy=self.dependencies[TokenEconomy]
    
    holding_time=tokeneconomy.price*tokeneconomy.transactions_volume_in_tokens/(tokeneconomy.transactions_value_in_fiat++0.000000001)
    
    if self._noise_addon!=None:
        dummy=self._noise_addon.apply(**{&#39;value&#39;:price_new})

        if dummy+holding_time&gt;0:
            holding_time=dummy+holding_time
    if holding_time&lt;self.minimum:
        holding_time=self.minimum
    elif holding_time&gt;self.maximum:
        holding_time=self.maximum
    
    self.holding_time=holding_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Constant"><code class="flex name class">
<span>class <span class="ident">HoldingTime_Constant</span></span>
<span>(</span><span>holding_time: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Constant holding time</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>holding_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The holding time. Needs to be positive.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If holding_time&lt;0 then raise Exception.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoldingTime_Constant(HoldingTimeController):
    &#34;&#34;&#34;
    Constant holding time
    &#34;&#34;&#34;
    
    def __init__(self,holding_time:float):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        holding_time : float
            The holding time. Needs to be positive.

        Raises
        ------
        Exception
            If holding_time&lt;0 then raise Exception.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super(HoldingTime_Constant,self).__init__()

        if holding_time&lt;=0:
            raise Exception(&#39;Holding time needs to be a positive real value!&#39;)
        self.holding_time=holding_time</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController">HoldingTimeController</a></li>
<li>baseclasses.Controller</li>
</ul>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic"><code class="flex name class">
<span>class <span class="ident">HoldingTime_Stochastic</span></span>
<span>(</span><span>holding_time_dist: <module 'scipy.stats' from '/Users/stylianoskampakis/opt/anaconda3/envs/kalgera3/lib/python3.9/site-packages/scipy/stats/__init__.py'> = &lt;scipy.stats._continuous_distns.halfnorm_gen object&gt;, holding_time_params: Dict = {'loc': 0, 'scale': 1}, minimum: float = 0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses a probability distribution and samples a random holding time per iteration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>holding_time_dist</code></strong> :&ensp;<code>scipy.stats</code>, optional</dt>
<dd>&nbsp;</dd>
<dt>A scipy distribution to sample the holding time from. The default is scipy.stats.halfnorm.</dt>
<dt><strong><code>holding_time_params</code></strong> :&ensp;<code>Dict</code>, optional</dt>
<dd>The parameters of the distribution. The default is {'loc':0,'scale':1}.</dd>
<dt><strong><code>minimum</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum possible holding time. If the sampled holding time is &lt;1, then it reverts to minimum. The default is 0.1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoldingTime_Stochastic(HoldingTimeController):
    &#34;&#34;&#34;
    Uses a probability distribution and samples a random holding time per iteration.
    &#34;&#34;&#34;
    
    def __init__(self,holding_time_dist:scipy.stats=scipy.stats.halfnorm,holding_time_params:Dict={&#39;loc&#39;:0,&#39;scale&#39;:1},
                 minimum:float=0.1):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        holding_time_dist : scipy.stats, optional
           A scipy distribution to sample the holding time from. The default is scipy.stats.halfnorm.
        holding_time_params : Dict, optional
            The parameters of the distribution. The default is {&#39;loc&#39;:0,&#39;scale&#39;:1}.
        minimum : float, optional
            The minimum possible holding time. If the sampled holding time is &lt;1, then it reverts to minimum. The default is 0.1.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.distribution=holding_time_dist
        self.dist_params=holding_time_params
        self.minimum=minimum
        self.execute()
        
        
    def execute(self)-&gt;float:
        &#34;&#34;&#34;
        

        Returns
        -------
        float
            The holding time.

        &#34;&#34;&#34;
        seed=int(int(time.time())*np.random.rand())

        self.holding_time=self.distribution.rvs(size=1,**self.dist_params,random_state=seed)[0]
        if self.holding_time&lt;self.minimum:
            self.holding_time=self.minimum
        
        return self.holding_time</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController">HoldingTimeController</a></li>
<li>baseclasses.Controller</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The holding time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self)-&gt;float:
    &#34;&#34;&#34;
    

    Returns
    -------
    float
        The holding time.

    &#34;&#34;&#34;
    seed=int(int(time.time())*np.random.rand())

    self.holding_time=self.distribution.rvs(size=1,**self.dist_params,random_state=seed)[0]
    if self.holding_time&lt;self.minimum:
        self.holding_time=self.minimum
    
    return self.holding_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController"><code class="flex name class">
<span>class <span class="ident">PriceFunctionController</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for price controllers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriceFunctionController(Controller):
    &#34;&#34;&#34;
    Abstract class for price controllers.
    
    &#34;&#34;&#34;
        
    
    def __init__(self):
       super(PriceFunctionController,self).__init__()
       self.dependencies={TokenEconomy:None}
       self.price=None
    
    def execute(self)-&gt;float:
        iteration+=1
        pass
    
    def get_price(self)-&gt;float:
        
        return self.price</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>baseclasses.Controller</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE">PriceFunction_EOE</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self)-&gt;float:
    iteration+=1
    pass</code></pre>
</details>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.get_price"><code class="name flex">
<span>def <span class="ident">get_price</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_price(self)-&gt;float:
    
    return self.price</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE"><code class="flex name class">
<span>class <span class="ident">PriceFunction_EOE</span></span>
<span>(</span><span>noise_addon: baseclasses.AddOn = None, smoothing_param: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple implementation of equation of exchange. Can also implement noise through AddOns.</p>
<p>If the AddOns make the price go negative, then the price goes back to simple equation of exchange before
noise w as added.</p>
<h2 id="parameters">Parameters</h2>
<p>noise_AddOn: Optional, if this is used, then the noise is added to the price.
If the price is negative, then the noise add-on is ignored, and the returned price
is the price without the noise.</p>
<dl>
<dt><strong><code>smoothing_param</code></strong> :&ensp;<code>Float. If set below 1, then this applied a weighted average between the new price</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>and the old price. This causes an anchoring effect, since in practice the new price would
be anchored to some extent to the previous one. A smoothing_param of 0.9, for exaple
calculates the final price as 0.9<em>newprice+0.1</em>old_price</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriceFunction_EOE(PriceFunctionController):
    &#34;&#34;&#34;
    Simple implementation of equation of exchange. Can also implement noise through AddOns.
    
    If the AddOns make the price go negative, then the price goes back to simple equation of exchange before 
    noise w as added.
    &#34;&#34;&#34;
    
    def __init__(self,noise_addon:AddOn=None,smoothing_param:float=1):
        &#34;&#34;&#34;
        
        Parameters
        ----------
        
        noise_AddOn: Optional, if this is used, then the noise is added to the price.
        If the price is negative, then the noise add-on is ignored, and the returned price
        is the price without the noise.
        
        smoothing_param: Float. If set below 1, then this applied a weighted average between the new price
        and the old price. This causes an anchoring effect, since in practice the new price would 
        be anchored to some extent to the previous one. A smoothing_param of 0.9, for exaple
        calculates the final price as 0.9*newprice+0.1*old_price
        &#34;&#34;&#34;
        super(PriceFunction_EOE,self).__init__()
        self._noise_addon=noise_addon
        
        if smoothing_param&gt;1 or smoothing_param&lt;0:
            raise Exception(&#39;Smoothing param must be in [0,1]&#39;)
        else:
            self.smoothing_param=smoothing_param
    
    def execute(self)-&gt;float:  
        tokeneconomy=self.dependencies[TokenEconomy]
        
        transaction_volume_in_fiat=tokeneconomy.transactions_value_in_fiat
        holding_time=tokeneconomy.holding_time
        #supply_of_tokens=tokeneconomy.transactions_value_in_tokens
        supply_of_tokens=tokeneconomy.supply
        
                

        #noise adjustment
        price_new=holding_time*transaction_volume_in_fiat/supply_of_tokens
        
        price_new=self.smoothing_param*price_new+(1-self.smoothing_param)*tokeneconomy.price
        
        if self._noise_addon!=None:
            price_new_2=self._noise_addon.apply(**{&#39;value&#39;:price_new})
        else:
            price_new_2 = -1
            
        if price_new_2&lt;0:
            self.price=price_new
        else:
            self.price=price_new_2
        
        self.iteration+=1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController">PriceFunctionController</a></li>
<li>baseclasses.Controller</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self)-&gt;float:  
    tokeneconomy=self.dependencies[TokenEconomy]
    
    transaction_volume_in_fiat=tokeneconomy.transactions_value_in_fiat
    holding_time=tokeneconomy.holding_time
    #supply_of_tokens=tokeneconomy.transactions_value_in_tokens
    supply_of_tokens=tokeneconomy.supply
    
            

    #noise adjustment
    price_new=holding_time*transaction_volume_in_fiat/supply_of_tokens
    
    price_new=self.smoothing_param*price_new+(1-self.smoothing_param)*tokeneconomy.price
    
    if self._noise_addon!=None:
        price_new_2=self._noise_addon.apply(**{&#39;value&#39;:price_new})
    else:
        price_new_2 = -1
        
    if price_new_2&lt;0:
        self.price=price_new
    else:
        self.price=price_new_2
    
    self.iteration+=1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.TokenLab.simulationcomponents" href="index.html">src.TokenLab.simulationcomponents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController">HoldingTimeController</a></code></h4>
<ul class="">
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.execute" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.execute">execute</a></code></li>
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.get_holding_time" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTimeController.get_holding_time">get_holding_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive">HoldingTime_Adaptive</a></code></h4>
<ul class="">
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive.execute" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Adaptive.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Constant" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Constant">HoldingTime_Constant</a></code></h4>
</li>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic">HoldingTime_Stochastic</a></code></h4>
<ul class="">
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic.execute" href="#src.TokenLab.simulationcomponents.pricingclasses.HoldingTime_Stochastic.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController">PriceFunctionController</a></code></h4>
<ul class="">
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.execute" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.execute">execute</a></code></li>
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.get_price" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunctionController.get_price">get_price</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE">PriceFunction_EOE</a></code></h4>
<ul class="">
<li><code><a title="src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE.execute" href="#src.TokenLab.simulationcomponents.pricingclasses.PriceFunction_EOE.execute">execute</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>